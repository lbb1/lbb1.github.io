<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Vue</title>
<style type="text/css">
     body{margin: 0;padding-left: 0}
    .active{color: blue}.fs-10{font-size:10px}.fs-12{font-size:12px}.fs-14{font-size:14px}.fs-15{font-size:15px}.fs-16{font-size:16px}.fs-17{font-size:17px}.fs-18{font-size:18px}.fs-20{font-size:20px}.fs-22{font-size:22px}.fs-24{font-size:24px}.fs-25{font-size:25px}.fs-26{font-size:26px}.fs-30{font-size:30px}.fs-32{font-size:32px}.fs-34{font-size:34px}.fs-36{font-size:36px}.fs-36{font-size:36px}.fs-38{font-size:38px}.fs-45{font-size:45px}.fs-46{font-size:46px}.fs-54{font-size:54px}
    .error{font-weight: bold}
    .red{color: red}
    #app{padding-bottom: 30px}
</style>
</head>
<body>

<script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"></script>


<div id="app">
<br>
    <div v-bind:title="message">{{message}}</div>

<br>
    <div v-if="see">See</div>

<br>
    <ol>
        <li v-for="todo in todos">{{todo.text}}</li>
    </ol>

<br>
    <div>{{reverse}}</div>
    <button v-on:click="toReverse">toReverse</button>

<br>    
    <div>{{names}}</div>
    <input type="" v-model="names" name="">

<br>
    <ol>
        <lbb-item></lbb-item>
    </ol>

<br>
    <ol>
        <todo-item 
            v-for="item in groceryList"
            v-bind:todo="item"
            v-bind:key="item.id"
        ></todo-item>
    </ol>

<br>
    <div>{{setHtml}}</div>
    <div v-html="setHtml"></div>

<br>
    <button v-bind:disabled="isDisabled">disabled</button>

<br>
    <form v-on:submit.prevent="onSubmit">
        <input type="" name="test" value="22">
        <button type="submit">post</button>
    </form>

<br>
    <a v-bind:href="url">v-bind:缩写</a>
    <a :href="url">:缩写</a>

<br>
    <div v-on:click="Alert">v-on:缩写</div>
    <div @click="Alert">@click</div>

<br>
    <div>{{message.split('').reverse().join('')}}</div>
    <div>{{reverseMessage2}}</div>
    <div>{{reverseMessage()}}</div>

<br>
    <div v-once>{{message}}</div>
<br>
    <div>{{firstName}}</div>
    <div>{{lastName}}</div>
    <div>{{fullName}}</div>

<br>
	<input type="" v-model="question" name="" placeholder="输入问题">
	<div>答案：{{answer}}</div>

<br>
    <div :class="{active:isActive}">v-bind:class="{active:isActive}"</div>

<br>
    <div class="fs-26" :class="{active:isActive,error:isError}">v-bind:class="{active:isActive}"</div>

<br>
    <div :class="classObject">v-bind:class="classObject"</div>

<br>
    <div :class="classObject2">计算属性</div>

<br>
    <div :class="[activeClass,errorClass]">数组语法</div>

<br>
    <div :class="[isActive?'active':'red']">三元表达式</div>

<br>
    <div :class="[isActive?activeClass:errorClass]">三元表达式2</div>

<br>
    <div :class="[{active:isActive},errorClass]">数据语法和对象语法相结合</div>

<br>
    <lbb-item :class="{active:isActive}">组件的基础上增加class</lbb-item>

<br>
    <div :style="{color:myColor,fontSize:mySize}">绑定内联样式1:v-bind:style="{color:myColor,font-size:mySize}"</div>

<br>
    <div :style="myFont">绑定内联样式2 v-bind:style="myFont"</div>

<br>
    <div :style="[myFont]">绑定内联样式3 v-bind:style="myFont"</div>

<br>
    <div :style="{display:['-webkit-box','-ms-flexbox','flex']}">内联样式多重值 :style="{display:['-webkit-box','-ms-flexbox','flex']}"</div>

<br>
    <h1 v-if="yes">Yes</h1>
    <h1 v-else>No</h1>

<br>
    <template v-if="ok">
        <h1>Title</h1>
        <p>page1</p>
        <p>page2</p>
    </template>

<br>
    <div v-if="yes">Yes</div>
    <div v-else-if="ok">OK</div>
    <div v-else>YESOK</div>

<!--
    <template> 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 <template> 元素
    Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。
    Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key 属性即可

    v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。
    v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
    v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换
    
    v-show 不支持 <template> 元素，也不支持 v-else。

    一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。
    当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级
-->
<br>
    <template v-if="loginType == 'userName'">
        <input type="" placeholder="enter your username" name="" key="name">
    </template>
    <template v-else>
        <input type="" placeholder="enter your email" name="" key="email">
    </template>

<br>
    <div v-show="yes">YES</div>

<br>
    <ul>
        <li v-for="item in todos">{{item.text}}</li>
    </ul>

<br>
    <ul>
        <li v-for="(item,index) in todos">{{index}}--{{item.text}}</li>
    </ul>

<br>
    <ul>
        <li v-for="item of todos">{{item.text}}</li>
    </ul>

<!--
    Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项
    的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素
-->
<br>
    <ul>
        <li v-for="(value,key,index) in object" :class="key=='firstName'?'red':''">
            {{index}}-{{key}}:{{value}}
        </li>
    </ul>
<!--
这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。
为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。
理想的 key 值是每项都有的唯一 id。这个特殊的属性相当于 Vue 1.x 的 track-by ，但它的工作方式类似于一个属性，所以你需要用 
v-bind 来绑定动态值

建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。
因为它是 Vue 识别节点的一个通用机制，key 并不与 v-for 特别关联，key 还具有其他用途，我们将在后面的指南中看到其他用途。
-->
<br>
    <ul>
        <li v-for="(value,key,index) in object" :class="key=='firstName'?'red':''" :key='index'>
            {{index}}-{{key}}:{{value}}
        </li>
    </ul>

<br>
    <ul>
        <li v-for="(item,index) of groceryList" :class="item.id==0?'red':''" :key="item.id">
            {{item.text}}
        </li>
    </ul>

<!--
    数组更新检测
        变异方法:Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下：
        push()  pop() shift() unshift() splice() sort() reverse()
        替换数组: filter(), concat() 和 slice()
      你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用
      而实现了一些智能的、启发式的方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。
      Vue 不能检测以下变动的数组:
          当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue
          当你修改数组的长度时，例如：vm.items.length = newLength
-->
<br>
    <ul>
        <li v-for="item in items">{{item}}</li>
    </ul>
    <!--为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新
        Vue.set(vm.items, indexOfItem, newValue)
        vm.items.splice(indexOfItem, 1, newValue)
        你也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名：
        vm.$set(vm.items, indexOfItem, newValue)
        为了解决第二类问题，你可以使用 splice
        vm.items.splice(newLength)

        还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除
        对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, key, value)
        方法向嵌套对象添加响应式属性
    -->
    <!--
        有时你可能需要为已有对象赋予多个新属性，比如使用 Object.assign() 或 _.extend()。在这种情况下，你应该用两个对象的属性创建一个
        新的对象。所以，如果你想添加新的响应式属性，不要像这样
        Object.assign(vm.userInfo,{
            age: 27,
            favoriteColor: 'red'
        })
        应该这样:
        vm.userInfo = Object.assign({},vm.userInfo,{
            age: 27,
            favoriteColor: 'red'
        })
    -->

<br>
    <ul>
        <li v-for="num in evenNumbers">{{num}}</li>
        <li v-for="num in even(numbers)">{{num}}</li>
    </ul>
    <template v-for="num in evenNumbers">
        <li>{{num}}</li>
        <li>{{num+1}}</li>
    </template>

<br>
    <button @click="counter++">Add +</button>
    <div>{{counter}}</div>

<br>
    <button @click="greet">Greet</button>
    <button @click="Alert('Hi')">Alert</button>
    <button @click="Alert('Cannot submitted',$event)">Alert enent</button>

<br>
    <!-- 阻止单击事件继续传播 -->
    <a v-on:click.stop="doThis"></a>
    <!-- 提交事件不再重载页面 -->
    <form v-on:submit.prevent="onSubmit"></form>
    <!-- 修饰符可以串联 -->
    <a v-on:click.stop.prevent="doThat"></a>
    <!-- 只有修饰符 -->
    <form v-on:submit.prevent></form>
    <!-- 添加事件监听器时使用事件捕获模式 -->
    <!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 -->
    <div v-on:click.capture="doThis">...</div>
    <!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
    <!-- 即事件不是从内部元素触发的 -->
    <div v-on:click.self="doThat">...</div>
    <div @click="Con('冒泡')">
        AAAAAA
        <div @click.once="Con('阻止冒泡')">阻止冒泡</div>
    </div>
    <div @click="Con('冒泡')">
        AAAAAA
        <div @click.stop="Con('阻止冒泡')">阻止冒泡</div>
    </div> 

    <input type="" @keyup.enter="Con(this)" name="">

<br>
     <input type="checkbox" v-model="checked">
     <div>{{checked}}</div>
 
 <br>
    <input type="checkbox" v-model="t_name" value="AA">
    <input type="checkbox" v-model="t_name" value="BB">
    <input type="checkbox" v-model="t_name" value="CC">
    <div>{{t_name}}</div>

 <br>
    <input type="radio" name="radios" v-model="radio" value="AA">AA
    <input type="radio" name="radios" v-model="radio" value="BB">BB
    <div>{{radio}}</div>

 <br>
    <select v-model="selected">
        <option disabled="">请选择</option>
        <option>AA</option>
        <option>BB</option>
    </select>
    <div>{{selected}}</div>

    <select v-model="selected2" multiple>
        <option disabled="">请选择</option>
        <option>AA</option>
        <option>BB</option>
    </select>
    <div>{{selected2}}</div>

    <select v-model="selected3">
        <option v-for="keys in groceryList" :value="keys.id">{{keys.text}}</option>
    </select>
    <div>{{selected3}}</div>

    <select v-model="selected">
        <option :value="{number:222}">123</option>
    </select>
    <div>{{selected.number}}</div>

 <br>  
    <input v-model="toggle" type="checkbox" true-value="yes" false-value="no" name="">
    <div>{{toggle}}</div>

    <input type="radio" name="" v-model="pick" :value="'a'">
    <div>{{pick}}</div>

<!--修饰符
    lazy:在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。
    你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步：
    number: 如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符
    trim: 如果要自动过滤用户输入的首尾空白字符
-->
 <br>  
    <input v-model.lazy="names" >
    <div>{{names}}</div>
    <input v-model.number="question" >
    <div>{{question}}</div>
    <input v-model.trim="firstName" >
    <div>{{firstName}}</div>

 <br>  
    <button-counter></button-counter>

 <br>  
    <blog-post title="3333"></blog-post>
    <blog-post title="4444"></blog-post>
    <blog-post v-for="post in posts" :key="post.id" :title="post.text"></blog-post>
    <blog-post2 v-for="post in posts" :key="post.id" :title="post.text"></blog-post2>



    
</div>
<script type="text/javascript" color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="test.js"></script>

<script type="text/javascript">

    Vue.component('lbb-item',{
        template: '<li class="fs-26">this is a component</li>'
    });

    Vue.component('todo-item',{
        props: ['todo','key'],
        template: '<li v-bind:id="todo.id">{{todo.text}}</li>'
    })

    Vue.component('todo-item2',{
        props: ['text'],
        template: '<li >{{title}} <button :click="$emit(remove)">Remove</button></li> '
    });

    Vue.component('button-counter',{
        data: function(){
            return {
                count: 0
            }
        },
        template: '<button @click="count++">{{count}}</button>'
    });

    Vue.component('blog-post',{
        props: ['title'],
        template: '<h3>{{title}}</h3>'
    })

    Vue.component('blog-post2',{
        props: ['title'],
        template: '<div class="blog-post">\
                        <h3>{{title}}</h3>\
                        <h2>{{title}}</h2>\
                  </div>'
    })

    var app = new Vue({
        el: "#app",
        data: {
            message: "lbbb"+new Date().toLocaleString(),
            see: true,
            index:0,
            todos: [
                {text: "AAA"},
                {text: "BBB"},
                {text: "CCC"}
            ],
            reverse: "reverse",
            names: "lbb",
            groceryList: [
              { id: 0, text: '蔬菜' },
              { id: 1, text: '奶酪' },
              { id: 2, text: '随便其它什么人吃的东西' }
            ],
            setHtml: '<span style="color:red">red</span>',
            isDisabled: true,
            url:"http://www.ickey.cn",

            firstName: 'Foo',
            lastName: 'Bar',

            question: "",
            answer: "I can't give you an answer until ask a question",

            isActive: true,
            isError: false,
            classObject:{
                active: true,
                'error': true
            },

            activeClass: 'active',
            errorClass: 'error',

            myColor: 'green',
            mySize: '16px',

            myFont: {
                color: 'red',
                fontSize: '22px',
                opacity:.7,
            },

            yes: true,
            ok: true,
            loginType: 'userName',

            object:{
                firstName: 'lbb',
                age: 30
            },
            
            items: ['a','b','c'],

            numbers: [1,2,3,4,5],

            counter:0,
            checked: true,
            t_name: [],

            radio: '',

            selected:'',
            selected2:[],
            selected3: '',

            toggle:'no',
            pick:'',
            posts:[
                {id:1,text:'a'},
                {id:2,text:'b'}
            ]


        },
        beforeCreate: function(){//组件刚被创建 ,组件属性计算之前（data以及$el都未初始化）
            this.index++;
            //console.log('beforeCreate---------'+this.index,this.$el);
        },
        created: function(){//组件实例创建完成，属性已经绑定dom未生成,(data已初始化,$el属性还不存在)
            this.index++;
            //console.log('created---------'+this.index,this.$el)
        },
        beforeMount: function(){//编译模板挂在之前
            this.index++;
            //console.log('beforeMount---------'+this.index,this.$el)
        },
        mounted: function(){//编译模板挂载之后
            this.index++;
            //console.log('mounted---------'+this.index,this.$el)
        },
        beforeUpdate: function(){//组件更新之前
            this.index++;
            //console.log('beforeUpdate---------'+this.index)
        },
        updated: function(){//组件更新之后
            this.index++;
            //console.log('updated---------'+this.index,this.$el)
        },
        activated: function(){//for keep-alive,组件被激活时调用
            this.index++;
            //console.log('activated---------'+this.index,this.$el)
        },
        deactivated: function(){//for keep-alive,组件被移除时调用
            this.index++;
            //console.log('deactivated---------'+this.index,this.$el)
        },
        beforeDestroy: function(){//组件销毁前调用
            this.index++;
            //console.log('beforeDestory---------'+this.index,this.$el)
        },
        destroyed: function(){//组件销毁后调用
            this.index++;
            //console.log('destoryed---------'+this.index,this.$el)
        },
        methods: {
            toReverse: function(){
                this.reverse = this.reverse.split('').reverse().join('');
            },
            onSubmit: function(){
                //console.log("submit success!")
            },
            Alert:function(message,event){
                if(event) event.preventDefault;
                alert(message)
            },
            Con: function(msg){
                console.log(msg)
            },
            reverseMessage: function () {
	            return this.message.split('').reverse().join('');
		    },
            even: function(numbers){
                return numbers.filter(function(number){
                    return number % 2 === 0
                })
            },
            greet: function(event){
                alert('hello----' + this.name);
                if(event){
                    alert(event.target.tagName)
                }
            }
        
        },

        /**
        *  计算属性 VS 侦听属性
        Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，
        你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调
        */
        watch: {
        	firstName: function(_val){
        		this.fullName = _val + " " + this.lastName
        	},
        	lastName: function(_val){
        		this.fullName = this.firstName + " " + _val
        	},
        	question: function(_val){
        		this.answer = this.question+"222"
        	}

        	//侦听器----虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一
        	//个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的
        },
        
        //计算属性----我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，
        //不同的是计算属性是基于它们的依赖进行缓存的。只在相关依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，
        //多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。
        computed:{
        	reverseMessage2: function(){
            	return this.message.split('').reverse().join('');
            },
            // fullName: function(){
            // 	return this.firstName + " " + this.lastName
            // },

            //计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：
            fullName: {
            	//getter
            	get: function(){
            		return this.firstName+ " " + this.lastName
            	},
            	//setter
            	set: function(_val){
            		_val = _val.split(" ");
            		this.firstName = _val[0];
            		this.lastName = _val[_val.length-1];
            	}
            },

            classObject2: function(){
                return {
                    active: this.isActive,
                    error: this.isError
                }
            },

            evenNumbers: function(){
                return this.numbers.filter(function(number){
                    return number % 2 === 0
                })
            },
        },

    });

    //Object.freeze(app.$data);
    //app.$destroy();
    //var index = 0;
    //while(index < 100){
      //  index++;
        //document.getElementsByClassName("reward-btn")[0].click();
        //document.querySelector("[gochange]").click();
        //document.getElementsByClassName("btn-exchange")[0].click();
    //}

    

</script>














</body>
</html>