<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>LBB's Blog</title>
<style type="text/css">
    html{
        overflow-y: auto;
        overflow-x: hidden;
    }
    body{
        width: 100vw;
        margin: 0;
        padding: 0 0 100px 0;
        font-family: Tahoma,Verdana,Arial,"Microsoft Yahei",sans-serif;
        font-size: 14px;
        background: #7c8e7917;
        color: #17561ef7;
    }
    h1{font-size: 24px;}
    h2{font-size: 20px;}
    h3{
        font-size: 18px;
        margin: 20px 0 0 0;
        cursor: pointer;
    }
    h4{font-size: 16px;}
    h5{font-size: 14px;}
    h6{font-size: 12px;}
    code{
        font-size: 13px;
        font-family: 微软雅黑;
        letter-spacing: .02rem;
        line-height: 20px;
    }
    pre{
        margin: 0;
        display: none;
    }
    .contain{
        padding-top: 100px;
        margin: auto;
        width: 1000px;
    }
    .fb{
        font-weight: bold;
    }
</style>
</head>
<body>
    <div class="contain">

    <h3>一、如何准确判断一个变量是数组类型</h3>
    <pre><code>
        var sss = [],
        fn = function(){};
        console.log(sss instanceof Array);
        console.log(fn instanceof Function);
    </code></pre>

    <h3>二、写一个原型链继承的例子</h3>
    <pre><code>
        function Animal(){
            this.eat = function(){
                console.log('animal eat');
            }
        };
        function Dog(){
            this.bark = function(){
                console.log('dog bark')
            }
        };
        Dog.prototype = new Animal();
        var hashiqi = new Dog();
    </code></pre>

    <h3>三、封装 DOM 查询</h3>
    <pre><code>
        function elem(dom){
            if(!dom) return false;
            this.getElem = document.querySelectorAll(dom);
            console.log(this.getElem);
        };

        elem.prototype.html = function(val){
            var self = this;
            if(val){
                for(var i = 0;i &lt; self.getElem.length;i++){
                    self.getElem[i].innerHTML = val;
                }
            }else{
                return self.getElem[0].innerHTML
            }
        };

        elem.prototype.on = function(type,fn){
            var self = this;
            for(var i = 0;i &lt; self.getElem.length;i++){
                self.getElem[i].addEventListener(type,fn)
            };
            return this
        };

        var elems = new elem('[href="lbb"]');
        elems.html('haha');
        elems.on('click',function(){
        })
    </code></pre>

    <h3>四、描述 new 一个对象的过程</h3>
    <pre><code>
        1)构造函数
                function Foo(name,age){
                    this.name = name;
                    this.age = age;
                    this.class = 'class';
                    //return this //默认有
                };
                var f = new Foo('lbb',18);

                1.创建一个新对象
                2.this 指向这个新对象
                3.执行代码，即对 this 赋值
                4.返回 this
                new 的过程：
                1.var f = new Foo('zhangsan',20)  将参数传进去，函数中的 this 会变成空对象
                2.this.name = name;this.age = age;this.class = 'class-1' 为赋值；return this 为实际的运行机制
                3.return 之后赋值给 f ，f 具备了 f.name = zhangsan、f.age = 20、f.class = 'class-1'
                4.继续执行到 f1 ,则 f1.name = lisi、f1.age = 22、f1.class = 'class-1'
        
        2)构造函数（扩展）
                1.var a = {} 其实是 var a = new Object()的语法糖  （a 的构造函数是 Object 函数）
                2.var a = [] 其实是 var a = new Array()的语法糖    （a 的构造函数是 Array 函数）
                3.function Foo(){...}其实是 var Foo = new Function(...)     （Foo 的构造函数是 Function 函数）
                4.使用 instanceof 判断一个函数是否是一个变量的构造函数   (判断一个变量是否为“数组”  变量 instanceof Array)
        
        3)原型规则

            1.所有的引用类型（数组、对象、函数）都具有对象特性，即可自由扩展属性（除了“null”）
                    var obj = {}; obj.a = 100;
                    var arr = []; arr.a = 100;
                    function fn(){}; fn.a = 100;

            2.所有的引用类型（数组、对象、函数）都有一个 __proto__ 属性(隐式原型属性），属性值是一个普通的对象
                    obj.__ptoto    arr.__proto__     fn.__proto__

            3.所有的函数，都有一个 prototype(显式原型）属性，属性值也是一个普通的对象
                    fn.prototype

            4.所有的引用类型（数组、对象、函数）， _proto_ 属性值(隐式原型属性）指向它的构造函数的“prototype”属性值
                    obj.__proto__ === Object.prototype
                    当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的_proto_(即它的构造函数的 prototype（显式原型）)中寻找

            5.构造函数
                    function Foo(name,age){
                        this.name = name;
                    };
                    Foo.prototype.alertName = function(){
                        alert(this.name)
                    };

            6.创建实例
                    var f = new Foo('lbb');
                    f.printName = function(){
                        alert(this.name)
                    };
                    f.printName();
                    f.alertName();
                    f.toString();

            7.instanceof 判断 引用类型 属于哪个 构造函数 的方法
                    console.log(f instanceof Foo);
                    console.log(f instanceof Object);
    </code></pre>

    <h3>五、this</h3>
    <pre><code>
        a. this表示当前对象，如果在全局作用范围内使用this，则指代当前页面对象window；
        b. 如果在函数中使用this，则this指代什么是根据运行时此函数在什么对象上被调用。 我们还可以使用apply和call两个全局方法来改变函数中this的具体指向。

        function foo(){
            console.log(this.a)
        };

        1) 隐式绑定
                    var a = 2;
                    var obj = {
                        a: 3,
                        foo:foo
                    };
                    obj.foo();

        2) 多层调用链（原则是获取最后一层调用的上下文对象）
                    var a = 2;
                    var obj1 = { 
                        a: 4,
                        foo: foo 
                    };
                    var obj2 = { 
                        a: 3,
                        obj1: obj1
                    };
                    obj2.obj1.foo();

        3) 隐式丢失（函数别名）
                    var a = 2;
                    var obj = { 
                        a: 3,
                        foo: foo 
                    };
                    var bar = obj.foo;
                    bar(); //?

        4) 隐式丢失（回调函数）
            -虽然参传是obj.foo，因为是引用关系，所以传参实际上传的就是foo对象本身的引用。对于setTimeout的调用，
            还是 setTimeout -> 获取参数中foo的引用参数 -> 执行 foo 函数，中间没有obj的参与。这里依旧进行的是默认绑定。
                var a = 2;
                var obj = { 
                    a: 3,
                    foo: foo 
                };
                setTimeout(obj.foo, 100 ); // ？
                setTimeout(function(){
                    obj.foo()
                }, 100 ); // ？

        5) 硬绑定
            虽然bar被显示绑定到obj2上，对于bar，function(){…} 中的this确实被绑定到了obj2，
            而foo因为通过foo.call( obj1 )已经显示绑定了obj1，所以在foo函数内，this指向的是obj1，不会因为bar函数内指向obj2而改变自身。
                var a = 2;
                var obj1 = { 
                    a: 3,
                };
                var obj2 = { 
                    a: 4,
                };
                var bar = function(){
                    foo.call( obj1 );
                }
                setTimeout( bar, 100 ); // 
                bar.call( obj2 ); // 
            
        6) null和undefined的绑定
            在显示绑定中，对于null和undefined的绑定将不会生效。
                var a = 2;
                function foo() { 
                    console.log( this.a );
                }
                foo.call( null );
                foo.call( undefined );
            这种情况主要是用在不关心this的具体绑定对象（用来忽略this），而传入null实际上会进行默认绑定，导致函数中可能会使用到全局变量，与预期不符。
            所以对于要忽略this的情况，可以传入一个空对象ø，该对象通过Object.create(null)创建。这里不用{}的原因是，ø是真正意义上的空对象，它不创建Object.prototype委托，{}和普通对象一样，有原型链委托关系。
    </code></pre>

    <h3>六、js继承</h3>
    <pre><code>
        1) 原型链继承
                 function Person(){
                    this.name = 'mike';
                 };
                 function Child(){
                    this.child = 'child';
                 };
                 Child.prototype = new Person();
                 var _child = new Child();
                 console.log(_child.child);
                 console.log(_child.name);

                 function Brother(){
                    this.weight = 60;
                 };
                 Brother.prototype = new Child();
                 var _brother = new Brother();
                 console.log(_brother.name);
                 console.log(_brother.child);
                 console.log(_brother.weight);

        2) 类式继承（借用构造函数）
                类式继承一般是通过运用call或者apply 进行子类型构造函数的内部调用超类型的构造函数。
                function Person(age){
                   this.name = ['mike','lbb'];
                   this.age = age;
                };
                function Child(age){
                   Person.call(this,age)
                };
                var _child = new Child('mpp');
                console.log(_child.name);
                console.log(_child.age);

        3) 组合继承
                function Person(age){
                   this.name = 'lbb';
                   this.age = age;
                };
                Person.prototype.run = function(){
                   return this.name + "_" + this.age
                };
                
                function Child(age){
                   Person.call(this,age)
                };
                Child.prototype = new Person();
                var _child = new Child('18');
                console.log(_child.name);
                console.log(_child.run());

        4) 原型式继承
                var myNew = {
                    name: 'lbb',
                    getName: function(){
                        return this.name
                    },
                    says: function(){
                        return this.saying || ''
                    }
                };

                var cat = Object.create(myNew);
                cat.name = 'mpp';
                cat.saying = 'hello';
                cat.getName = function(){
                    console.log( this.says + "_" + this.name + "_" + this.says );
                };
                cat.getName();
                //低版本没有浏览器 Object.create 替代方法
                function obj(o){
                    function f(){};
                    f.prototype = o;
                    return new f();
                };

                var box = {
                    name: 'lbb',
                    arr : ['18','boy']
                };
                var b1 = obj(box);
                console.log(b1.name);

    </code></pre>


    </div>
</body>
<script type="text/javascript">
    function Another(ori){
        var clone = new Object(ori);
        clone.say = function(){
            alert('hi')
        };
        return clone
    };
    var person = {
        name: 'lbb',
        frd: ['mpp','haha']
    };
    var obj = Another(person);
    obj.say(); 


</script>
<!-- <script type="text/javascript" color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="assets/src/js/test.js"></script> -->
<script type="text/javascript" src="assets/src/js/jquery.js"></script>
</html>




<script type="text/javascript">
$(function(){

    var indexPage = function(){
        this.$body = $('body');

        this.keys = {
            'new':'',
            'function': '',
            'var': '',
            'if': '',
            'else': '',
            'break': '#a626a4',
            ' in ': '',
            'if': '',
            'return':'#a626a4'
        };
        this.init();
    };

    indexPage.prototype.init = function(){
        this.fnKey();
        this.event();
    };

    indexPage.prototype.event = function(){
        var self = this;

        self.$body.on('click',"h3",function(){
            var _next = $(this).next();
            _next.css('display') == 'none' ?_next.slideDown():_next.slideUp();
        });
    };

    indexPage.prototype.fnKey = function(){
        var self = this;
        var keys = self.keys;
        /**
        *code需要处理关键词
        * <: &lt;
        * >: &gt;
        * &: &amp;
        */
        $.each($('code'),function(index,value){
            var _self = $(this),
                _html = _self.html();
            for(var _key in keys){
                if(!keys.hasOwnProperty(_key))
                    continue;
                var _color = keys[_key] || '#2366ccc2';
                _html = _html.replace(new RegExp(_key,"gim"),'<span class="fb" style="color:'+_color+'">'+_key+'</span>');
            };
            _self.html(_html);
        });
    };

    var _indexPage = new indexPage;
    
    
    
});
/*
http://2017.makemepulse.com/
http://www.campoallecomete.it/#!/en
https://29a.ch/sandbox/2012/fluidwebgl/
https://www.valerian.bnpparibas/fr/intergalactic-mission
http://david.li/paint/
http://www.asitanosikaku.jp/works/
http://www.bongiovi.tw/experiments/webgl/blossom/
http://wow.techbrood.com/fiddle/3432?vm=full
http://wow.techbrood.com/fiddle/33518
http://wow.techbrood.com/fiddle/33513
http://wow.techbrood.com/fiddle/33510
http://wow.techbrood.com/fiddle/33452
http://wow.techbrood.com/fiddle/33395
http://wow.techbrood.com/fiddle/33378
http://wow.techbrood.com/fiddle/33371
http://wow.techbrood.com/fiddle/33343
http://wow.techbrood.com/fiddle/33344
http://wow.techbrood.com/fiddle/33264
http://wow.techbrood.com/fiddle/33226


https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/getUserMedia 
http://www.cnblogs.com/jscode/p/3601648.html
http://reactnative.cn/
http://www.cnblogs.com/fuqiang88/p/5577642.html
http://www.adobe.com/devnet/archive/html5/articles/css-shaders.html
https://mobile.ant.design/docs/react/introduce
https://www.behance.net/gallery/6364671/Mobile-Portfolio-Concept
*/
    

    
</script>
